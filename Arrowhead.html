<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>3D Arrowhead</title>
    <link rel="stylesheet" type="text/css" href="css/gfx-scene.css" />
    <!-- Set the viewport size to the screen size, so it will be displayed maximized, but unscaled. -->
    <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1"/>

    <!-- Include several libraries from THREE.js and the Scene class  -->
    <script src="three-js/three.js"></script>
    <script src="three-js/Detector.js"></script>
    <script src="three-js/stats.js"></script>

    <script src="gfx/dat.gui.min.js"></script>
    <script src="gfx/OrbitControls-Touch-Ortho.js"></script>
    <script src="gfx/math-ext.js"></script>
    <script src="gfx/gfx-scene.js"></script>

</head>

<body>

<script>



    // allocate the Scene object, request orbitControls, some of 3D axes 10 units high and the stats
    let gfxScene = new GFX.Scene( {
        cameraPos : [4, 3, 4],
        controls:true,
        defaultLights: true,
        axesHeight:10,
        displayStats:true} );

    initializeDemo();

    animateScene();

    /**
     * Initialize the Demo.
     */
    function initializeDemo() {

        const geometry = new THREE.BufferGeometry();

        const vertices = new Float32Array([
            // front
            -1, -1, 1, 1, -1, 1, -1, 1,  1,
            -1,  1, 1, 1, -1, 1,  1, 1,  1,
            // back
            1, -1, -1, -1, -1, -1,  1, 1, -1,
            1,  1, -1, -1, -1, -1, -1, 1, -1,
            // left
            -1, -1, -1, -1, -1, 1, -1, 1, -1,
            -1,  1, -1, -1, -1, 1, -1, 1,  1,
            // right
            1, -1, 1, 1, -1, -1, 1, 1,  1,
            1,  1, 1, 1, -1, -1, 1, 1, -1,
            // top
            1,  1, -1, -1, 1, -1,  1, 1, 1,
            1,  1,  1, -1, 1, -1, -1, 1, 1,
            // bottom
            1, -1,  1, -1, -1, 1,  1, -1, -1,
            1, -1, -1, -1, -1, 1, -1, -1, -1,
        ])

        geometry.addAttribute('position', new THREE.BufferAttribute(vertices, 3));

        const material = new THREE.MeshLambertMaterial({ color: 0x990000, wireframe: true});
        const mesh = new THREE.Mesh(geometry, material);

        gfxScene.add(mesh);

        drawArrow( 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0);
    }

    /**
     * Animate the scene and call rendering.
     */
    function animateScene() {

        // Tell the browser to call this function when page is visible
        requestAnimationFrame(animateScene);

        // Map the 3D scene down to the 2D screen (render the frame)
        gfxScene.renderScene();
    }

    /**
     *  Draws an arrow at the specified location and scale
     *
     * @param locX
     * @param locY
     * @param locZ
     * @param scaleX
     * @param scaleY
     * @param scaleZ
     * @param rot
     * @constructor
     */
    function drawArrow ( locX, locY, locZ, scaleX, scaleY, scaleZ, rot ) {


        let TIPY        = 0.75;	// position in Y of arrow-head tip
        let TIPX        = 0.0;	// position in X of arrow-head tip
        let BASE        = 0.1;	// base of arrow-head in Y
        let HEAD_WIDTH  = 0.3;	// half-width of the arrow-head in X
        let NEG_HEAD_WIDTH  = -0.3;	// half-width of the arrow-head in X
        let SHAFT_WIDTH = 0.1;	// half-width of the arrow-shaft in X
        let NEG_SHAFT_WIDTH = -0.1;	// half-width of the arrow-shaft in X
        let SHAFT_END   = -0.5;	// end of the arrow-shaft in Y
        let THICKNESS   = 0.5;	// half-thickness of the arrow in Z
        let NEG_THICKNESS   = -0.5;	// half-thickness of the arrow in Z

        // head of the arrow
        let   	vA = { x:NEG_HEAD_WIDTH,  y:BASE,  z:THICKNESS };
        let		vB = {  x:TIPX,        y:TIPY,  z:THICKNESS };
        let		vC = {  x:HEAD_WIDTH,  y:BASE,  z:THICKNESS };
        let		vD = { x:NEG_HEAD_WIDTH,  y:BASE, z:NEG_THICKNESS };
        let		vE = { x:TIPX,        y:TIPY, z:NEG_THICKNESS };
        let		vF = {  x:HEAD_WIDTH,  y:BASE, z:NEG_THICKNESS };

        // the tail, i.e. the box part of the arrow
        let		vG = { x:NEG_SHAFT_WIDTH, y:BASE,      z:THICKNESS };
        let		vH = {  x:SHAFT_WIDTH, y:BASE,      z:THICKNESS };
        let		vI = { x:NEG_SHAFT_WIDTH, y:SHAFT_END, z:THICKNESS };
        let		vJ = {  x:SHAFT_WIDTH, y:SHAFT_END, z:THICKNESS };
        let		vK = { x:NEG_SHAFT_WIDTH, y:BASE,      z:NEG_THICKNESS };
        let		vL = {  x:SHAFT_WIDTH, y:BASE,      z:NEG_THICKNESS };
        let		vM = { x:NEG_SHAFT_WIDTH, y:SHAFT_END, z:NEG_THICKNESS };
        let		vN = {  x:SHAFT_WIDTH, y:SHAFT_END, z:NEG_THICKNESS };

        let nFaces = 16;
        let nVerticesPerFace = 3;
        let nColorComponents = 3;
        let coordsPerVertex = 3;
        let nVerts = nFaces * nVerticesPerFace * coordsPerVertex;

        const arrowVerts = new Float32Array(nVerts);
        let  counter = { n: 0 };

        // the head of the arrow
        triangleFace( vC, vB, vA, arrowVerts, counter );
        triangleFace( vB, vC, vF, arrowVerts, counter  );
        triangleFace( vB, vF, vE, arrowVerts, counter  );
        triangleFace( vC, vA, vD, arrowVerts, counter  );
        triangleFace( vC, vD, vF, arrowVerts, counter  );
        triangleFace( vA, vB, vD, arrowVerts, counter  );
        triangleFace( vB, vE, vD, arrowVerts, counter  );
        triangleFace( vE, vF, vD, arrowVerts, counter );         //don't need the bottom of the arrow!

        // the tail, i.e. the box part of the arrow
        triangleFace( vG, vI, vJ, arrowVerts, counter  );
        triangleFace( vG, vJ, vH, arrowVerts, counter  );
        triangleFace( vH, vJ, vN, arrowVerts, counter  );
        triangleFace( vH, vN, vL, arrowVerts, counter  );
        triangleFace( vI, vG, vM, arrowVerts, counter  );
        triangleFace( vM, vG, vK, arrowVerts, counter  );
        triangleFace( vJ, vI, vM, arrowVerts, counter  );
        triangleFace( vJ, vM, vN, arrowVerts, counter  );

        const arrowGeometry = new THREE.BufferGeometry();
        arrowGeometry.addAttribute('position', new THREE.BufferAttribute(arrowVerts, 3));
        const arrowColors = [];
        for ( let i=0; i<nVerts; i++ ) {
            arrowColors.push( 255, 0, 0 );
        }
        arrowGeometry.addAttribute('color', new THREE.Float32BufferAttribute(arrowColors, 3));

        const material = new THREE.MeshBasicMaterial({ vertexColors:true });
        const mesh = new THREE.Mesh(arrowGeometry, material);

        gfxScene.add(mesh);
    }

    /**
     * Defines single, normalized triangle face
     *
     * @param vA
     * @param vB
     * @param vC
     * @param arrowVerts
     * @param counter
     * @constructor
     */
    function triangleFace ( vA, vB, vC, arrowVerts, counter ) {
        let n = counter.n;
        arrowVerts[n++] = vA.x;
        arrowVerts[n++] = vA.y;
        arrowVerts[n++] = vA.z;
        arrowVerts[n++] = vB.x;
        arrowVerts[n++] = vB.y;
        arrowVerts[n++] = vB.z;
        arrowVerts[n++] = vC.x;
        arrowVerts[n++] = vC.y;
        arrowVerts[n++] = vC.z;
        counter.n = n;
    }
</script>

</body>

</html>